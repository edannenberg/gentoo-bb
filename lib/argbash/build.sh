#!/bin/bash

_help_command_description="Build image(s) or namespace(s)"

# ARG_POSITIONAL_INF([target-id],[Namespace or image to build, i.e. myns or myns/myimage],[1])
# ARG_OPTIONAL_BOOLEAN([interactive],[i],[Starts an interactive phase 1 build container. It's parent image has to be built already])
# ARG_OPTIONAL_BOOLEAN([no-deps],[n],[Ignore all parent images and only build passed target-id(s), only full image id's allowed])
# ARG_OPTIONAL_BOOLEAN([force-image-build],[f],[Rebuild any existing images of current dependency graph])
# ARG_OPTIONAL_BOOLEAN([force-full-image-build],[F],[Rebuild any existing images including the first build phase])
# ARG_OPTIONAL_BOOLEAN([clear-build-container],[c],[Force rebuild of required build container(s) if existing])
# ARG_OPTIONAL_BOOLEAN([clear-everything],[C],[Force rebuild of required build container(s) and their respective stage3 images])
# ARG_OPTIONAL_BOOLEAN([skip-gpg-check],[s],[Don't verify downloads with GPG, sha512 is still checked])
# ARG_OPTIONAL_REPEATED([exclude],[e],[Exclude given image from dependency graph for this run])
# ARGBASH_WRAP([opt-global])
# ARG_HELP([])
# ARGBASH_SET_INDENT([    ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.3.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_target_id=('' )
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_interactive=off
_arg_no_deps=off
_arg_force_image_build=off
_arg_force_full_image_build=off
_arg_clear_build_container=off
_arg_clear_everything=off
_arg_skip_gpg_check=off
_arg_exclude=()
_arg_verbose=off

print_help ()
{
    printf 'Usage: %s [--(no-)interactive] [--(no-)no-deps] [--(no-)force-image-build] [--(no-)force-full-image-build] [--(no-)clear-build-container] [--(no-)clear-everything] [--(no-)skip-gpg-check] [-e|--exclude <arg>] [--(no-)verbose] [-h|--help] <target-id-1> [<target-id-2>] ... [<target-id-n>] ...\n' "$0"
    printf "\t%s\n" "<target-id>: Namespace or image to build, i.e. myns or myns/myimage"
    printf "\t%s\n" "-i,--interactive,--no-interactive: Starts an interactive phase 1 build container. It's parent image has to be built already (off by default)"
    printf "\t%s\n" "-n,--no-deps,--no-no-deps: Ignore all parent images and only build passed target-id(s), only full image id's allowed (off by default)"
    printf "\t%s\n" "-f,--force-image-build,--no-force-image-build: Rebuild any existing images of current dependency graph (off by default)"
    printf "\t%s\n" "-F,--force-full-image-build,--no-force-full-image-build: Rebuild any existing images including the first build phase (off by default)"
    printf "\t%s\n" "-c,--clear-build-container,--no-clear-build-container: Force rebuild of required build container(s) if existing (off by default)"
    printf "\t%s\n" "-C,--clear-everything,--no-clear-everything: Force rebuild of required build container(s) and their respective stage3 images (off by default)"
    printf "\t%s\n" "-s,--skip-gpg-check,--no-skip-gpg-check: Don't verify downloads with GPG, sha512 is still checked (off by default)"
    printf "\t%s\n" "-e,--exclude: Exclude given image from dependency graph for this run (empty by default)"
    printf "\t%s\n" "-h,--help: Prints help"
}

# THE PARSING ITSELF
while test $# -gt 0
do
    _key="$1"
    case "$_key" in
        -i*|--no-interactive|--interactive)
            _arg_interactive="on"
            _next="${_key##-i}"
            test -n "$_next" && test "$_next" != "$_key" && shift && set -- "-i" "-${_next}" "$@"
            test "${1:0:5}" = "--no-" && _arg_interactive="off"
            ;;
        -n*|--no-no-deps|--no-deps)
            _arg_no_deps="on"
            _next="${_key##-n}"
            test -n "$_next" && test "$_next" != "$_key" && shift && set -- "-n" "-${_next}" "$@"
            test "${1:0:5}" = "--no-" && _arg_no_deps="off"
            ;;
        -f*|--no-force-image-build|--force-image-build)
            _arg_force_image_build="on"
            _next="${_key##-f}"
            test -n "$_next" && test "$_next" != "$_key" && shift && set -- "-f" "-${_next}" "$@"
            test "${1:0:5}" = "--no-" && _arg_force_image_build="off"
            ;;
        -F*|--no-force-full-image-build|--force-full-image-build)
            _arg_force_full_image_build="on"
            _next="${_key##-F}"
            test -n "$_next" && test "$_next" != "$_key" && shift && set -- "-F" "-${_next}" "$@"
            test "${1:0:5}" = "--no-" && _arg_force_full_image_build="off"
            ;;
        -c*|--no-clear-build-container|--clear-build-container)
            _arg_clear_build_container="on"
            _next="${_key##-c}"
            test -n "$_next" && test "$_next" != "$_key" && shift && set -- "-c" "-${_next}" "$@"
            test "${1:0:5}" = "--no-" && _arg_clear_build_container="off"
            ;;
        -C*|--no-clear-everything|--clear-everything)
            _arg_clear_everything="on"
            _next="${_key##-C}"
            test -n "$_next" && test "$_next" != "$_key" && shift && set -- "-C" "-${_next}" "$@"
            test "${1:0:5}" = "--no-" && _arg_clear_everything="off"
            ;;
        -s*|--no-skip-gpg-check|--skip-gpg-check)
            _arg_skip_gpg_check="on"
            _next="${_key##-s}"
            test -n "$_next" && test "$_next" != "$_key" && shift && set -- "-s" "-${_next}" "$@"
            test "${1:0:5}" = "--no-" && _arg_skip_gpg_check="off"
            ;;
        -e*|--exclude|--exclude=*)
            _val="${_key##--exclude=}"
            _val2="${_key##-e}"
            if test "$_val" = "$_key"
            then
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _val="$2"
                shift
            elif test "$_val2" != "$_key" -a -n "$_val2"
            then
                _val="$_val2"
            fi
            _arg_exclude+=("$_val")
            ;;
        --no-verbose|--verbose)
            _arg_verbose="on"
            _args_opt_global_opt+=("${_key%%=*}")
            test "${1:0:5}" = "--no-" && _arg_verbose="off"
            ;;
        -h*|--help)
            print_help
            exit 0
            ;;
        *)
            _positionals+=("$1")
            ;;
    esac
    shift
done

_positional_names=('_arg_target_id' )
test ${#_positionals[@]} -lt 1 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1, but got only ${#_positionals[@]}." 1
_OUR_ARGS=$((${#_positionals[@]} - ${#_positional_names[@]}))
for (( ii = 0; ii < _OUR_ARGS; ii++))
do
    _positional_names+=("_arg_target_id[(($ii + 1))]")
done

for (( ii = 0; ii < ${#_positionals[@]}; ii++))
do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
done

# OTHER STUFF GENERATED BY Argbash
_args_opt_global=("${_args_opt_global_opt[@]}" "${_args_opt_global_pos[@]}")

### END OF CODE GENERATED BY Argbash (sortof) ### ])
